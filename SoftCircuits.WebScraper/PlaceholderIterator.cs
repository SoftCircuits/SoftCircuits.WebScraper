// Copyright (c) 2020-2021 Jonathan Wood (www.softcircuits.com)
// Licensed under the MIT license.
//

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace SoftCircuits.WebScraper
{
    /// <summary>
    /// Handles iterating through all URL placeholders.
    /// </summary>
    internal class PlaceholderIterator : List<PlaceholderIteratorItem>
    {
        /// <summary>
        /// URL template.
        /// </summary>
        private readonly string UrlTemplate;

        /// <summary>
        /// Constructs a new <see cref="PlaceholderIterator"/> instance.
        /// </summary>
        /// <param name="urlTemplate">The target URL with replacement tags.</param>
        public PlaceholderIterator(string urlTemplate)
        {
            UrlTemplate = urlTemplate ?? throw new ArgumentNullException(nameof(urlTemplate));
        }

        /// <summary>
        /// Adds a new <see cref="PlaceholderIteratorItem"/> to this iterator. The iterator is added
        /// only if it contains one or more value and its tag appears within the URL.
        /// </summary>
        /// <param name="item">The <see cref="PlaceholderIteratorItem"/> to add.</param>
        public new void Add(PlaceholderIteratorItem item)
        {
            if (item.Count > 0 && Placeholder.UrlContainsPlaceholder(UrlTemplate, item.Placeholder))
                base.Add(item);
        }

        /// <summary>
        /// Calculates the Returns the total number of different URL that will be generated by this class
        /// given the current number of placeholder iterators.
        /// </summary>
        public int GetTotalUrlCount()
        {
            int count = 1;
            foreach (PlaceholderIteratorItem item in this)
                count *= item.Count;
            return count;
        }

        /// <summary>
        /// Initializes the iterator.
        /// </summary>
        /// <param name="url"></param>
        public void Reset(out string url)
        {
            // Reset each item
            foreach (PlaceholderIteratorItem item in this)
                item.Reset();
            // Get the URL
            url = GetCurrentUrl();
        }

        /// <summary>
        /// Advances one of the placeholders and constructs a new URL.
        /// </summary>
        /// <param name="url">Returns the URL with the new placeholder values.</param>
#if NETSTANDARD2_0
        public bool Next(out string url)
#else
        public bool Next([NotNullWhen(true)] out string? url)
#endif
        {
            // Find next placeholder to increment
            for (int i = Count - 1; i >= 0; i--)
            {
                if (this[i].Next())
                {
                    // Get the URL
                    url = GetCurrentUrl();
                    return true;
                }
            }
            // No more variations
            url = null;
            return false;
        }

        /// <summary>
        /// Builds the URL with the current placeholder values.
        /// </summary>
        private string GetCurrentUrl()
        {
            string url = UrlTemplate;
            foreach (PlaceholderIteratorItem item in this)
                url = url.CaseInsensitiveReplace(item.Placeholder, item.CurrentValue);
            return url;
        }
    }
}
